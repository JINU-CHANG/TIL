## 객체 지향 특징

* 추상화
* 캡슐화
* 상속
* **다형성**

이중 다형성이 가장 중요하다.

## 객체 지향 프로그래밍이란 (Object-Oriented Programming, OOP)

* 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 **"객체"들의 모임**으로 파악하고자 하는 것이다. 각각의 객체는 **메시지**를 주고받고, 데이터를 처리할 수 있다.

* 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

### 유연하고 변경이 용이하다 ?

마치 레고 블럭을 조립하듯이, 컴퓨터 부품을 갈아 끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있다.

유연하고 변경 용이한 프로그래밍을 하기 위해서는 **역할**과 **구현**을 구분하는 것이 매우 중요하다.

실세계 예시를 들어보자.

운전자와 자동차는 각각 **역할**을 가지고 있다. 그리고 자동차의 역할을 실제로 **구현**한 아반떼, K3, 테슬라 자동차가 존재한다. 운전자가 K3를 타다가 아반떼로 차를 바꿔도 운전을 할 수 있다. 왜냐하면 구현체만 바뀌었을 뿐이지 자동차의 기능은 그대로 똑같기 때문이다. 운전자에게 영향을 주지 않는다.

예시가 가능한 이유는 운전자가 자동차 역할(인터페이스)에 대해서만 의존하고 있기 때문이다. 운전자는 자동차가 내부적으로 어떻게 구현되어있는지 몰라도 된다.

### 역할과 구현을 분리

* 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경이 편리해진다.
* 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
* 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
* 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
* 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.

## 다형성(Polymorphism)

자바 언어에서는 다형성을 활용해 역할과 구현을 분리한다.

다형성은 하나의 타입에 여러 객체를 대입할 수 있는 성질이다. 이러한 다형성을 구현한 예시로 **오버라이딩**을 대표적으로 들 수 있는데, 인터페이스를 구현한 객체를 **실행 시점에 유연하게 변경** 할 수 있다.

다형성이 객체 지향에서 중요한 이유는, 다형성을 구현하기 위해서는 여러 객체들 중 공통 특성으로 타입을 추상화하고 그것을 상속(인터페이스라면 구현) 해야 하는데 이 특성들을 유기적으로 잘 활용했을 때 변경에 유연한 프로젝트를 만들 수 있고 비로소 객체 지향에 가까운 코드를 작성할 수 있기 때문이다.

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

1. SRP 단일 책임 원칙

    * 한 클래스는 하나의 책임만 가져야 한다.
    * 하나의 책임이라는 것은 상황에 따라 모호할 수 있는데, 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.

2. OCP 개방-폐쇄 원칙

    * 소프트웨어 요소는 **확장에는 열려** 있으나, **변경에는 닫혀** 있어야 한다.
    * 인터페이스를 새로 구현해서 확장을 하는 것은 기존 코드를 변경하는 것은 아니다. 하지만 바꾸기 위해서는 변경이 필요하다.

    ```
    public class MemberService {

        private MemberRepository memberRepository = new MemoryMemberRepository();
    }

    public class MemberService {

        private MemberRepository memberRepository = new JdbcMemberRepository();
    }

    분명 위에서 아래 코드로 바꾸는데 코드 변경이 일어났다.
    ```

    구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다!

    -> 이것을 스프링 컨테이너가 해결해준다.

3. LSP 리스코프 치환 원칙

    * 서브 타입은 프로그램의 정확성을 깨뜨리지 않으면서 언제나 기반 타입으로 교체할 수 있어야 한다. 예를 들어, 자동차 인터페이스의 엑셀은 앞으로 가라는 기능인데 이를 뒤로 가게 구현했다면 LSP 원칙을 위배한 것이다.
    * 다형성을 지원하기 위한 원칙으로 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

4. ISP 인터페이스 분리 원칙

    * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
    * 인터페이스가 명확해지고, 대체 가능성이 높아진다.

5. DIP 의존관계 역전 원칙

    * 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 즉, 앞서 이야기한 역할(Role)에 의존해야 한다.
    * 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만 동시에 구현 클래스에도 의존한다.

    ```
    public class MemberService {

        private MemberRepository memberRepository = new MemoryMemberRepository();
    }
    ```

다형성만으로는 OCP, DIP를 지킬 수 없다. 뭔가 더 필요하다.


### AppConfig 등장

* 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스

```
public class AppConfig {

    public MemberService memberService() {
        return new MemberService(new MemoryMemberRepository());
    }
}
```
* AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
* AppConfig는 생성한 객체 인스턴의 참조를 생성자를 통해서 주입해준다.

위의 DIP 원칙을 지킬 수 없었던 코드는 AppConfig 설정을 통해 아래처럼 변경할 수 있다.

 ```
    public class MemberService {

        private final MemberRepository memberRepository;

        public MemberService(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
    }
```

* 설계 변경으로 MemberService는 MemoryMemberRepository를 의존하지 않고, 단지 MemberRepository 인터페이스만 의존한다.
* MemberService 입장에서는 생성자를 통해 어떤 구현 객체가 들어올지 알 수 없다.
* MemberServiceImpl 은 이제부터 **의존관계에 대한 고민은 외부**에 맡기고 **실행에만 집중**하면 된다.
* MemberService는 MemberRepository인 추상에만 의존하면 되기 때문에 DIP가 지켜진다.

스프링은 다음 기술로 **다형성 + OCP, DIP**를 가능하게 해주는 기술이다.
* DI(Dependency Injection) : 의존관계, 의존성 주입
* DI 컨테이너 제공


---
참고
* https://tecoble.techcourse.co.kr/post/2020-10-27-polymorphism/





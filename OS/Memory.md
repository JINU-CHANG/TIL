## 메모리 구조

* Text 영역(Code 영역)
    * 프로그램을 실행시키기 위해 구성되는 것들이 저장되는 영역
    * 제어문, 함수, 상수들이 이 영역에 저장된다.

* Data 영역
    * 작성한 코드에서 전역변수, 정적변수 등이 저장되는 공간
    * 보통 메인 함수 전에 선언되어 프로그램이 끝날 때까지 메모리에 남아있는 변수들이라는 특징이 있다. (static 변수)

* Heap 영역
    * '사용자에 의해 관리되는 영역' 으로 흔히 동적으로 할당할 변수들이 여기에 저장된다.
    * Heap 영역은 대개 '낮은 주소'에서 '높은 주소'로 할당된다.

* Stack 영역
    * 함수를 호출할 때 지역변수, 매개변수들이 저장되는 공간
    * 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제시킨다.
    * Heap 영역과 반대로 높은 주소에서 낮은 주소로 메모리에 할당된다.

## 메모리의 주소공간

메모리에 저장된 정보의 위치는 **주소**로 나타낼 수 있고 이 주소에는 두 종류인 **물리 주소와 논리 주소**가 있다. 

**물리 주소(physical address)**는 메모리 하드웨어가 사용하는 주소이고, **논리 주소(virtual address)**는 CPU와 실행 중인 프로그램이 사용하는 주소이다.

### 왜 두 종류의 주소로 나뉘게 되었는가 ?

메모리에 저장된 정보는 시시각각 변한다. 메모리에는 새롭게 실행되는 프로그램이 시시때때로 적재되고, 실행이 끝난 프로그램은 삭제된다. 따라서 CPU와 실행 중인 프로그램은 메모리 주소가 어떻게 바뀌었는지 알고 있기 어렵다. 이런 문제점을 극복하기 위해 물리 주소와 논리 주소로 나누어 관리하기 시작했다. 

물리 주소는 메모리 입장에서 바라본 주소, 말 그대로 정보가 실제로 저장된 하드웨어 상의 주소를 의미한다. 논리 주소는 CPU와 실행중인 프로그램 입장에서 바라본 주소로 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소를 의미한다. 논리 주소는 **기준주소로부터 떨어진 거리**를 뜻하기도 한다.

<img src="https://github.com/JINU-CHANG/TIL/assets/98975580/a261915f-e185-4cef-a874-1a2288aa76b9" width="500" height="200">

CPU는 정확한 메모리 주소(물리주소)를 알 필요 없이 논리 주소값만 알고 있으면 된다. 그러면 논리 주소를 물리 주소로 변환시켜주는 **MMU(메모리 관리 장치)**에 의해 값이 변환되고, 메모리 주소가 변경되었더라고 정확한 곳의 메모리 값을 참조할 수 있다.

MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터값을 더하여 논리 주소를 물리 주소로 변환한다. **베이스 레지스터**는 기준주소의 역할을 한다. 물리 구조상의 프로그램 시작 주소이다. 아래의 예시를 보면 프로그램 A는 15000 부터 시작되는 물리주소를 가지고 있기 때문에 베이스 레지스터 값은 15000 이며, CPU에 의해 15000 + 100 에 있는 데이터가 삭제된다.

<img src="https://github.com/JINU-CHANG/TIL/assets/98975580/38e94ae0-cbf8-4f09-9564-f6de886a30b6" width="500" height="200">

### 메모리 보호

만약 인터넷 브라우저의 물리적 주소가 2000 ~ 2999 번라고 할 때, CPU가 인터넷 브라우저 1100번지 데이터를 삭제하라!라고 명령하면 어떻게 될까?

해당 데이터의 물리 주소는 베이스 레지스터값(2000) + 논리주소 (1100) 을 해서 3100 번지가 된다. 하지만 3100번대는 게임의 물리 주소이므로 엉뚱한 값이 삭제되는 문제가 발생할 수 있다.

이렇게 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호할 방법이 필요하다.

**한계 레지스터** 를 통해 보호할 수 있는데 이는 논리 주소의 최대 크기를 저장한다. 프로그램의 물리 주소 범위는 베이스 레지스터 값 이상(시작점) 베이스 레지스터 값 + 한계 레지스터값(크기) 값 미만이라고 할 수 있다. 예를 들어 게임의 베이스 레지스터 값이 3000이고 크기가 1000이라면 게임의 물리 주소는 3000번지 ~ 4000번지까지일 것이다. 

CPU가 접근하려는 논리 주소는 한계 레지스터가 저장한 값보다 커서는 안 된다. CPU 는 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사한다. 만약 CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 이넡럽트를 발생시켜 중단한다. 

### 32비트 vs 64비트

32비트 및 64비트는 컴퓨터 프로세서(CPU)가 정보를 처리하는 방식을 가리킨다.

비트는 CPU가 처리하는 데이터의 최소 단위인 **레지스터** 크기가 몇 비트인지에서 나온말이다. 즉 레지스터의 크기가 32비트, 64비트라는 것이다. 

CPU의 레지스터는 처리의 지연시간을 줄이기 위해 사용하고 있는 임시기억장치이다. 데이터를 처리할 때 CPU를 통해 처리하는데, 매번 메모리에서 데이터를 가져오게 되면 시간 낭비가 되고 지연이 생기기 때문에 CPU 내부에 임시 기억장치인 레지스터를 두어 메모리에서 데이터를 가져와서 저장하고 필요할때마다 불러와서 처리한다. 레지스터 용량이 클수록 메모리에서 더 많은 데이터를 가져와 저장할 수 있기 때문에 처리 속도도 더 빨라지게 된다.

32비트 기준으로 2^32 = 4,294,967,296개 숫자를 표현할 수 있고, 그만큼의 메모리 주소를 저장할 수 있다. 메모리 주소값의 단위는 **1바이트** 이므로 총 4,294,967,296 바이트의 메모리 주소를 가리킬 수 있다.

이때 **4,294,967,296바이트 = 4,194,304KB = 4,096MB = 4GB**이다. 따라서 램에서 한번에 표현할 수 있는 메모리의 크기가 4GB이다. 



